use anyhow::Result;
use serde::{Deserialize, Serialize};
use crate::git::DiffInfo;

#[derive(Debug, Serialize, Deserialize)]
pub struct AIResponse {
    pub content: String,
    pub confidence: Option<f32>,
}

pub async fn generate_pr_description(diff_info: &DiffInfo) -> Result<String> {
    let commits_summary = diff_info.commits.iter()
        .map(|c| format!("- {}: {}", &c.hash[..8], c.message))
        .collect::<Vec<_>>()
        .join("\n");
    
    let files_summary = diff_info.commits.iter()
        .flat_map(|c| &c.files_changed)
        .collect::<std::collections::HashSet<_>>()
        .iter()
        .map(|f| format!("- {}", f))
        .collect::<Vec<_>>()
        .join("\n");
    
    // For now, return a simple template-based description
    // In a real implementation, you would call OpenAI API here
    let description = format!(
        "# Pull Request Description\n\n## Summary\nThis PR includes {} commits affecting {} files.\n\n## Changes\n{}\n\n## Files Modified\n{}\n\n## Testing\nPlease test the following areas:\n- [ ] New functionality works as expected\n- [ ] Existing functionality is not broken\n- [ ] All tests pass\n\n## Notes\nThis description was generated by commit-buddy. Please review and update as needed.",
        diff_info.commits.len(),
        diff_info.total_files_changed,
        commits_summary,
        files_summary
    );
    
    Ok(description)
}

pub async fn generate_tests(diff_info: &DiffInfo, framework: &str) -> Result<String> {
    let code_changes = diff_info.commits.iter()
        .map(|c| format!("Commit {}: {}\nDiff:\n{}", &c.hash[..8], c.message, c.diff))
        .collect::<Vec<_>>()
        .join("\n\n");
    
    // For now, return a simple template-based test
    // In a real implementation, you would call OpenAI API here
    let tests = format!(
        "# Generated Tests for {} Framework\n\n## Test Template\n\n```{}\n# TODO: Implement actual tests based on code changes\n# This is a placeholder generated by commit-buddy\n\n# Example test structure:\n# def test_new_functionality():\n#     # Arrange\n#     # Act\n#     # Assert\n#     pass\n\n# def test_edge_cases():\n#     # Test edge cases and error conditions\n#     pass\n```\n\n## Code Changes Analyzed\n```\n{}\n```\n\n## Next Steps\n1. Review the code changes above\n2. Implement comprehensive tests\n3. Add edge case testing\n4. Ensure proper mocking of dependencies\n5. Run tests and verify coverage",
        framework,
        if framework == "auto" { "python" } else { framework },
        code_changes
    );
    
    Ok(tests)
}

pub async fn improve_commit_message(message: &str) -> Result<String> {
    // For now, return a simple improvement
    // In a real implementation, you would call OpenAI API here
    let improved = if message.len() > 50 {
        format!("{}...", &message[..47])
    } else {
        message.to_string()
    };
    
    Ok(format!("Improved: {}", improved))
}

pub async fn generate_commit_suggestions(diff_info: &DiffInfo) -> Result<Vec<String>> {
    let staged_changes = diff_info.commits.iter()
        .map(|c| format!("Files: {}\nDiff:\n{}", c.files_changed.join(", "), c.diff))
        .collect::<Vec<_>>()
        .join("\n\n");
    
    // For now, return simple suggestions
    // In a real implementation, you would call OpenAI API here
    let suggestions = vec![
        "feat: add new functionality".to_string(),
        "fix: resolve issue with existing code".to_string(),
        "docs: update documentation".to_string(),
    ];
    
    Ok(suggestions)
}

pub async fn generate_changelog(diff_info: &DiffInfo) -> Result<String> {
    let commits_summary = diff_info.commits.iter()
        .map(|c| format!("- {}: {}", &c.hash[..8], c.message))
        .collect::<Vec<_>>()
        .join("\n");
    
    // For now, return a simple template-based changelog
    // In a real implementation, you would call OpenAI API here
    let changelog = format!(
        "# Changelog\n\n## [Unreleased]\n\n### Added\n{}\n\n### Changed\n- Various improvements\n\n### Fixed\n- Bug fixes\n\n### Removed\n- Deprecated features\n\n---\n\n*This changelog was generated by commit-buddy.*",
        commits_summary
    );
    
    Ok(changelog)
}

pub async fn code_review(diff_info: &DiffInfo) -> Result<String> {
    let code_changes = diff_info.commits.iter()
        .map(|c| format!("Commit {}: {}\nDiff:\n{}", &c.hash[..8], c.message, c.diff))
        .collect::<Vec<_>>()
        .join("\n\n");
    
    // For now, return a simple template-based review
    // In a real implementation, you would call OpenAI API here
    let review = format!(
        "# Code Review\n\n## Summary\nThis review covers {} commits with changes to {} files.\n\n## Code Changes\n```\n{}\n```\n\n## Review Checklist\n- [ ] Code follows project style guidelines\n- [ ] Functions are well-documented\n- [ ] Error handling is appropriate\n- [ ] Performance considerations addressed\n- [ ] Security implications reviewed\n- [ ] Tests are comprehensive\n\n## Suggestions\n1. Consider adding more comprehensive error handling\n2. Ensure all public APIs are documented\n3. Add unit tests for new functionality\n4. Review for potential security vulnerabilities\n\n*This review was generated by commit-buddy.*",
        diff_info.commits.len(),
        diff_info.total_files_changed,
        code_changes
    );
    
    Ok(review)
}